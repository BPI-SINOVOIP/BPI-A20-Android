
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/init.h>
#include <mach/sys_config.h>
#include <mach/gpio.h>
#include <linux/proc_fs.h>
#include "wifi_pm.h"

#define wifi_pm_msg(...)    do {printk("[wifi_pm]: "__VA_ARGS__);} while(0)

#define MAX_WIFI_NUM  3
struct wifi_pm_ops wifi_select_pm_ops[MAX_WIFI_NUM];

static char* wifi_mod[] = {" ",
	"bcm40181",   /* 1 - BCM40181(BCM4330)*/
	"bcm40183",   /* 2 - BCM40183(BCM4330)*/
	"rtl8723as",  /* 3 - RTL8723AS(RF-SM02B) */
	"rtl8189es",  /* 4 - RTL8189ES(SM89E00) */
	"rtl8192cu",  /* 5 - RTL8192CU*/
	"rtl8188eu",  /* 6 - RTL8188EU*/
	"ap6210",     /* 7 - AP6210*/
	"ap6330",     /* 8 - AP6330*/
	"ap6181",     /* 9 - AP6181*/
	"rtl8723au",  /* 10 - RTL8723AU */
};

int wifi_pm_get_mod_type(void)
{
	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
	if (ops->wifi_used.val)
		return ops->module_sel.val;
	else {
		wifi_pm_msg("No select wifi, please check your config !!\n");
		return 0;
	}
}
EXPORT_SYMBOL(wifi_pm_get_mod_type);

int wifi_pm_gpio_ctrl(char* name, int level)
{
	struct wifi_pm_ops *ops = &wifi_select_pm_ops;	
	if (ops->wifi_used.val && ops->gpio_ctrl)		
		return ops->gpio_ctrl(name, level);	
	else {		
		wifi_pm_msg("No select wifi, please check your config !!\n");		
		return -1;	
	}
}
EXPORT_SYMBOL(wifi_pm_gpio_ctrl);

void wifi_pm_power(int on)
{
	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
	int power = on;
	if (ops->wifi_used.val && ops->power)
		return ops->power(1, &power);
	else {
		wifi_pm_msg("No select wifi, please check your config !!\n");
		return;
	}
}
EXPORT_SYMBOL(wifi_pm_power);

#ifdef CONFIG_PROC_FS
static int wifi_pm_power_stat(char *page, char **start, off_t off, int count, int *eof, void *data)
{
	struct wifi_pm_ops *ops = (struct wifi_pm_ops *)data;
	char *p = page;
	int power = 0;

	if (ops->power)
		ops->power(0, &power);

	p += sprintf(p, "%s : power state %s\n", ops->mod_name, power ? "on" : "off");
	return p - page;
}

static int wifi_pm_power_ctrl(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    struct wifi_pm_ops *ops = (struct wifi_pm_ops *)data;
    int power = simple_strtoul(buffer, NULL, 10);
    
    power = power ? 1 : 0;
    if (ops->power)
        ops->power(1, &power);
    else
        wifi_pm_msg("No power control for %s\n", ops->mod_name);
    return sizeof(power);	
}

static inline void awwifi_procfs_attach(int wifi_id)
{
	
	char proc_root[32] = {0}; 
	sprintf(proc_root, "driver/wifi-pm%d", wifi_id);
	struct wifi_pm_ops *ops = &wifi_select_pm_ops[wifi_id];
	
	ops->proc_root = proc_mkdir(proc_root, NULL);
	if (IS_ERR(ops->proc_root))
	{
		wifi_pm_msg("failed to create procfs \"driver/wifi-pm\".\n");
	}

	ops->proc_power = create_proc_entry("power", 0644, ops->proc_root);
	if (IS_ERR(ops->proc_power))
	{
		wifi_pm_msg("failed to create procfs \"power\".\n");
	}
	ops->proc_power->data = ops;
	ops->proc_power->read_proc = wifi_pm_power_stat;
	ops->proc_power->write_proc = wifi_pm_power_ctrl;
}

static inline void awwifi_procfs_remove(int wifi_id)
{
	char proc_root[32] = {0}; 
	sprintf(proc_root, "driver/wifi-pm%d", wifi_id);
	struct wifi_pm_ops *ops = &wifi_select_pm_ops[wifi_id];

	remove_proc_entry("power", ops->proc_root);
	remove_proc_entry(proc_root, NULL);
}
#else
static inline void awwifi_procfs_attach(void) {}
static inline void awwifi_procfs_remove(void) {}
#endif

static int wifi_pm_get_res(void)
{
	u32 i;
	char wifi_used_para[16] = {0};
	script_item_value_type_e type;
	struct wifi_pm_ops *ops;

	for (i=0; i<MAX_WIFI_NUM; i++) {	
		ops = &wifi_select_pm_ops[i];
		sprintf(wifi_used_para, "wifi%d_para", i);
		
		type = script_get_item(wifi_used_para, "wifi_used", &ops->wifi_used);
		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
			wifi_pm_msg("failed to fetch wifi configuration!\n");
			return -1;
		}
		if (!ops->wifi_used.val) {
			wifi_pm_msg("no wifi used in configuration\n");
			return -1;
		}

		type = script_get_item(wifi_used_para, "wifi_sdc_id", &ops->sdio_id);
		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
			wifi_pm_msg("failed to fetch sdio card's sdcid\n");
			return -1;
		}
		
		type = script_get_item(wifi_used_para, "wifi_usbc_id", &ops->usb_id);
		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
			wifi_pm_msg("failed to fetch usb's id\n");
			return -1;
		}	

		type = script_get_item(wifi_used_para, "wifi_mod_sel", &ops->module_sel);
		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
			wifi_pm_msg("failed to fetch sdio module select\n");
			return -1;
		}	
		ops->mod_name = wifi_mod[ops->module_sel.val];
		
		printk("[wifi_%d]: select wifi: %s !!\n", i, wifi_mod[ops->module_sel.val]);

	}

	return 0;
}


static int __devinit wifi_pm_probe(struct platform_device *pdev)
{
	int wifi_id = pdev->id
	struct wifi_pm_ops *ops = &wifi_select_pm_ops[wifi_id];

	wifi_pm_msg("%s: pdev->id = %d\n", __func__, wifi_id);
	
	switch (ops->module_sel.val) {
		case 1: /* BCM40181 */
			bcm40181_gpio_init();
			break;
		case 2: /* BCM40183 */
			bcm40183_gpio_init();
			break;
		case 3: /* RTL8723AS */
			rtl8723as_gpio_init();
			break;
		case 4: /* RTL8189ES */
			rtl8189es_gpio_init();
			break;
		case 5: /* RTL8192CU */
			rtl8192cu_gpio_init(wifi_id);
			break;
		case 6: /* RTL8188EU */
			rtl8188eu_gpio_init();
			break;
		case 7: /* AP6210 */
		case 8: /* AP6330 */
		case 9: /* AP6181 */
		case 10: /* AP6335 */
			ap6xxx_gpio_init();
			break;
		case 11: /* RTL8723AU */
			rtl8723au_gpio_init();
			break;
		case 12: /* RTL8821AU */
			rtl8821au_gpio_init();
            break;
		default:
			wifi_pm_msg("wrong sdio module select %d !\n", ops->module_sel.val);
	}

	awwifi_procfs_attach(wifi_id);
	
	wifi_pm_msg("wifi_%d gpio init is OK !!\n", wifi_id);
	
	return 0;
}

static int __devexit wifi_pm_remove(struct platform_device *pdev)
{
	awwifi_procfs_remove(pdev->id);
	wifi_pm_msg("wifi gpio is released !!\n");
	return 0;
}

#ifdef CONFIG_PM
static int wifi_pm_suspend(struct device *dev)
{
	struct wifi_pm_ops *ops = &wifi_select_pm_ops;

	if (ops->standby)
		ops->standby(1);
	return 0;
}

static int wifi_pm_resume(struct device *dev)
{
	struct wifi_pm_ops *ops = &wifi_select_pm_ops;

	if (ops->standby)
		ops->standby(0);
	return 0;
}

static struct dev_pm_ops wifi_dev_pm_ops = {
	.suspend	= wifi_pm_suspend,
	.resume		= wifi_pm_resume,
};
#endif

static struct platform_device wifi_pm_dev[] = {
	[0] = {.name = "wifi_pm", .id = 0},
	[1] = {.name = "wifi_pm", .id = 1},
	[2] = {.name = "wifi_pm", .id = 2},
};

static struct platform_driver wifi_pm_driver = {
	.driver.name    = "wifi_pm",
	.driver.owner   = THIS_MODULE,
#ifdef CONFIG_PM
	.driver.pm      = &wifi_dev_pm_ops,
#endif
	.probe          = wifi_pm_probe,
	.remove         = __devexit_p(wifi_pm_remove),
};

static int __init wifi_pm_init(void)
{
	struct wifi_pm_ops *ops;
	int ret, i;

	wifi_pm_msg("%s: driver initializied\n", __func__);
	
	ret = wifi_pm_get_res();
	if (unlikely(ret))
		return ret;

	for(i=0; i<MAX_WIFI_NUM; i++) {
		ops = &wifi_select_pm_ops[i];
		if(ops->wifi_used)
			platform_device_register(&wifi_pm_dev);
	}
	
	return platform_driver_register(&wifi_pm_driver);
}

static void __exit wifi_pm_exit(void)
{
	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
	if (!ops->wifi_used.val)
		return;

	memset(ops, 0, sizeof(struct wifi_pm_ops));
	platform_driver_unregister(&wifi_pm_driver);
}

module_init(wifi_pm_init);
module_exit(wifi_pm_exit);

