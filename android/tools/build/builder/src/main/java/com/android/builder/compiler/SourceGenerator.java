/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.builder.compiler;

import com.android.utils.ILogger;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

/**
 * Class to help generating Source code.
 */
public class SourceGenerator {

    private final ILogger mLogger;

    static enum DisplayType {
        FOUND, COMPILING, REMOVE_OUTPUT, REMOVE_DEP;
    }

    interface Processor {
        String getSourceFileExtension();
        void process(File filePath, List<File> sourceFolders, File sourceOutputDir, ILogger logger)
                throws IOException, InterruptedException;
        void displayMessage(ILogger logger, DisplayType type, int count);
    }

    public SourceGenerator(ILogger logger) {
        mLogger = logger;
    }

    public void processFiles(Processor processor, List<File> sourceFolders,
                             File sourceOutputDir) throws IOException, InterruptedException {

        String extension = processor.getSourceFileExtension();

        // gather all the source files from all the source folders.
        Map<File, File> sourceFiles = getFilesByNameEntryFilter(sourceFolders, extension);
        if (sourceFiles.size() > 0) {
            processor.displayMessage(mLogger, DisplayType.FOUND, sourceFiles.size());
        }

        // go look for all dependency files in the gen folder. This will have all dependency
        // files but we can filter them based on the first pre-req file.
        List<File> depFiles = getFilesByNameEntryFilter(sourceOutputDir, "d");

        // parse all the dep files and keep the ones that are of the proper type and check if
        // they require compilation again.
        Map<File, File> toCompile = Maps.newHashMap();
        ArrayList<File> toRemove = Lists.newArrayList();
        ArrayList<File> depsToRemove = Lists.newArrayList();
        for (File depFile : depFiles) {
            DependencyGraph graph = new DependencyGraph(depFile, null /*watchPaths*/, mLogger);

            // get the source file. it's the first item in the pre-reqs
            File sourceFile = graph.getFirstPrereq();
            String sourceFilePath = sourceFile.getAbsolutePath();

            // The gen folder may contain other dependency files not generated by this particular
            // processor.
            // We only care if the first pre-rep is of the right extension.
            if (sourceFilePath.toLowerCase(Locale.US).endsWith("." + extension)) {
                // remove from the list of sourceFiles to mark as "processed" (but not compiled
                // yet, that'll be done by adding it to toCompile)
                File sourceFolder = sourceFiles.get(sourceFile);
                if (sourceFolder == null) {
                    // looks like the source file does not exist anymore!
                    // we'll have to remove the output!
                    Set<File> outputFiles = graph.getTargets();
                    toRemove.addAll(outputFiles);

                    // also need to remove the dep file.
                    depsToRemove.add(depFile);
                } else {
                    // Source file is present. remove it from the list as being processed.
                    sourceFiles.remove(sourceFile);

                    // check if it needs to be recompiled.
                    if (graph.dependenciesHaveChanged(false /*printStatus*/)) {
                        toCompile.put(sourceFile, sourceFolder);
                    }
                }
            }
        }

        // add to the list of files to compile, whatever is left in sourceFiles. Those are
        // new files that have never been compiled.
        toCompile.putAll(sourceFiles);

        processor.displayMessage(mLogger, DisplayType.COMPILING, toCompile.size());
        if (toCompile.size() > 0) {
            for (Map.Entry<File, File> toCompilePath : toCompile.entrySet()) {
                processor.process(toCompilePath.getKey(), sourceFolders, sourceOutputDir, mLogger);
            }
        }

        if (toRemove.size() > 0) {
            processor.displayMessage(mLogger, DisplayType.REMOVE_OUTPUT, toRemove.size());

            for (File toRemoveFile : toRemove) {
                if (toRemoveFile.delete() == false) {
                    mLogger.warning("Failed to remove " + toRemoveFile.getAbsolutePath());
                }
            }
        }

        // remove the dependency files that are obsolete
        if (depsToRemove.size() > 0) {
            processor.displayMessage(mLogger, DisplayType.REMOVE_DEP, toRemove.size());

            for (File file : depsToRemove) {
                if (file.delete() == false) {
                    mLogger.warning("Failed to remove " + file.getAbsolutePath());
                }
            }
        }
    }

    /**
     * Returns a list of files found in given folders, all matching a given filter.
     * The result is a map of (file, folder).
     * @param folders the folders to search
     * @param extension the filter for the files. Typically a glob.
     * @return a map of (file, folder)
     */
    private Map<File, File> getFilesByNameEntryFilter(List<File> folders, String extension) {
        Map<File, File> sourceFiles = Maps.newHashMap();

        for (File folder : folders) {
            List<File> files = getFilesByNameEntryFilter(folder, extension);

            for (File f : files) {
                sourceFiles.put(f, folder);
            }
        }

        return sourceFiles;
    }

    /**
     * Returns a list of files found in a given folder, matching a given filter.
     * @param sourceFolder the folders to search
     * @param extension The file extension
     * @return an iterator.
     */
    private List<File> getFilesByNameEntryFilter(File sourceFolder, String extension) {
        ArrayList<File> result = Lists.newArrayList();

        if (sourceFolder.isDirectory()) {
            gatherFiles(sourceFolder, extension, result);
        }
        return result;
    }

    private void gatherFiles(File folder, String extension, ArrayList<File> result) {
        for (File f : folder.listFiles()) {
            if (f.isFile()) {
                String name = f.getName();
                if (name.substring(name.lastIndexOf('.') + 1).equals(extension)) {
                    result.add(f);
                }
            } else if (f.isDirectory()) {
                gatherFiles(f, extension, result);
            }
        }
    }
}
