// Generated Code - DO NOT EDIT !!
// generated by 'emugen'


#include <string.h>
#include "gl2_opcodes.h"

#include "gl2_enc.h"


#include <stdio.h>
static void enc_unsupported()
{
	ALOGE("Function is unsupported\n");
}

void glActiveTexture_enc(void *self , GLenum texture)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glActiveTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;
}

void glAttachShader_enc(void *self , GLuint program, GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glAttachShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &shader, 4); ptr += 4;
}

void glBindAttribLocation_enc(void *self , GLuint program, GLuint index, const GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_name =  (strlen(name) + 1);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_name + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBindAttribLocation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &index, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	memcpy(ptr, name, __size_name);ptr += __size_name;
}

void glBindBuffer_enc(void *self , GLenum target, GLuint buffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBindBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &buffer, 4); ptr += 4;
}

void glBindFramebuffer_enc(void *self , GLenum target, GLuint framebuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBindFramebuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &framebuffer, 4); ptr += 4;
}

void glBindRenderbuffer_enc(void *self , GLenum target, GLuint renderbuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBindRenderbuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &renderbuffer, 4); ptr += 4;
}

void glBindTexture_enc(void *self , GLenum target, GLuint texture)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBindTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;
}

void glBlendColor_enc(void *self , GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBlendColor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;
}

void glBlendEquation_enc(void *self , GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBlendEquation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
}

void glBlendEquationSeparate_enc(void *self , GLenum modeRGB, GLenum modeAlpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBlendEquationSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &modeRGB, 4); ptr += 4;
		memcpy(ptr, &modeAlpha, 4); ptr += 4;
}

void glBlendFunc_enc(void *self , GLenum sfactor, GLenum dfactor)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBlendFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &sfactor, 4); ptr += 4;
		memcpy(ptr, &dfactor, 4); ptr += 4;
}

void glBlendFuncSeparate_enc(void *self , GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBlendFuncSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &srcRGB, 4); ptr += 4;
		memcpy(ptr, &dstRGB, 4); ptr += 4;
		memcpy(ptr, &srcAlpha, 4); ptr += 4;
		memcpy(ptr, &dstAlpha, 4); ptr += 4;
}

void glBufferData_enc(void *self , GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data = ((data != NULL) ?  size : 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_data + 4 + 1*4;
	ptr = stream->alloc(8 + 4 + 4);
	int tmp = OP_glBufferData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (data != NULL) stream->writeFully(data, __size_data);
	ptr = stream->alloc(4);
		memcpy(ptr, &usage, 4); ptr += 4;
}

void glBufferSubData_enc(void *self , GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data =  size;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + __size_data + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4);
	int tmp = OP_glBufferSubData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_data,4);
	stream->writeFully(data, __size_data);
}

GLenum glCheckFramebufferStatus_enc(void *self , GLenum target)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCheckFramebufferStatus;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	GLenum retval;
	stream->readback(&retval, 4);
	return retval;
}

void glClear_enc(void *self , GLbitfield mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glClear;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mask, 4); ptr += 4;
}

void glClearColor_enc(void *self , GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glClearColor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;
}

void glClearDepthf_enc(void *self , GLclampf depth)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glClearDepthf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &depth, 4); ptr += 4;
}

void glClearStencil_enc(void *self , GLint s)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glClearStencil;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &s, 4); ptr += 4;
}

void glColorMask_enc(void *self , GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 1 + 1 + 1 + 1;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glColorMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &red, 1); ptr += 1;
		memcpy(ptr, &green, 1); ptr += 1;
		memcpy(ptr, &blue, 1); ptr += 1;
		memcpy(ptr, &alpha, 1); ptr += 1;
}

void glCompileShader_enc(void *self , GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCompileShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
}

void glCompressedTexImage2D_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glCompressedTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_data,4);
	if (data != NULL) stream->writeFully(data, __size_data);
}

void glCompressedTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data =  imageSize;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glCompressedTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_data,4);
	stream->writeFully(data, __size_data);
}

void glCopyTexImage2D_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCopyTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
}

void glCopyTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCopyTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
}

GLuint glCreateProgram_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 0;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCreateProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;


	GLuint retval;
	stream->readback(&retval, 4);
	return retval;
}

GLuint glCreateShader_enc(void *self , GLenum type)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCreateShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &type, 4); ptr += 4;

	GLuint retval;
	stream->readback(&retval, 4);
	return retval;
}

void glCullFace_enc(void *self , GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCullFace;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
}

void glDeleteBuffers_enc(void *self , GLsizei n, const GLuint* buffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_buffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_buffers + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDeleteBuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_buffers; ptr += 4;
	memcpy(ptr, buffers, __size_buffers);ptr += __size_buffers;
}

void glDeleteFramebuffers_enc(void *self , GLsizei n, const GLuint* framebuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_framebuffers + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDeleteFramebuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_framebuffers; ptr += 4;
	memcpy(ptr, framebuffers, __size_framebuffers);ptr += __size_framebuffers;
}

void glDeleteProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDeleteProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
}

void glDeleteRenderbuffers_enc(void *self , GLsizei n, const GLuint* renderbuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_renderbuffers + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDeleteRenderbuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_renderbuffers; ptr += 4;
	memcpy(ptr, renderbuffers, __size_renderbuffers);ptr += __size_renderbuffers;
}

void glDeleteShader_enc(void *self , GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDeleteShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
}

void glDeleteTextures_enc(void *self , GLsizei n, const GLuint* textures)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_textures =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_textures + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDeleteTextures;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_textures; ptr += 4;
	memcpy(ptr, textures, __size_textures);ptr += __size_textures;
}

void glDepthFunc_enc(void *self , GLenum func)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDepthFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;
}

void glDepthMask_enc(void *self , GLboolean flag)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 1;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDepthMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &flag, 1); ptr += 1;
}

void glDepthRangef_enc(void *self , GLclampf zNear, GLclampf zFar)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDepthRangef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;
}

void glDetachShader_enc(void *self , GLuint program, GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDetachShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &shader, 4); ptr += 4;
}

void glDisable_enc(void *self , GLenum cap)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDisable;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;
}

void glDisableVertexAttribArray_enc(void *self , GLuint index)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDisableVertexAttribArray;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;
}

void glDrawArrays_enc(void *self , GLenum mode, GLint first, GLsizei count)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDrawArrays;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &first, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
}

void glEnable_enc(void *self , GLenum cap)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glEnable;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;
}

void glEnableVertexAttribArray_enc(void *self , GLuint index)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glEnableVertexAttribArray;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;
}

void glFinish_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 0;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glFinish;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

}

void glFlush_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 0;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glFlush;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

}

void glFramebufferRenderbuffer_enc(void *self , GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glFramebufferRenderbuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &renderbuffertarget, 4); ptr += 4;
		memcpy(ptr, &renderbuffer, 4); ptr += 4;
}

void glFramebufferTexture2D_enc(void *self , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glFramebufferTexture2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &textarget, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
}

void glFrontFace_enc(void *self , GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glFrontFace;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
}

void glGenBuffers_enc(void *self , GLsizei n, GLuint* buffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_buffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_buffers + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGenBuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_buffers; ptr += 4;
	stream->readback(buffers, __size_buffers);
}

void glGenerateMipmap_enc(void *self , GLenum target)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGenerateMipmap;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
}

void glGenFramebuffers_enc(void *self , GLsizei n, GLuint* framebuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_framebuffers + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGenFramebuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_framebuffers; ptr += 4;
	stream->readback(framebuffers, __size_framebuffers);
}

void glGenRenderbuffers_enc(void *self , GLsizei n, GLuint* renderbuffers)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_renderbuffers + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGenRenderbuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_renderbuffers; ptr += 4;
	stream->readback(renderbuffers, __size_renderbuffers);
}

void glGenTextures_enc(void *self , GLsizei n, GLuint* textures)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_textures =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_textures + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGenTextures;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_textures; ptr += 4;
	stream->readback(textures, __size_textures);
}

void glGetActiveAttrib_enc(void *self , GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_size =  (sizeof(GLint));
	const unsigned int __size_type =  (sizeof(GLenum));
	const unsigned int __size_name = ((name != NULL) ?  bufsize : 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + __size_length + __size_size + __size_type + __size_name + 4*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetActiveAttrib;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_size; ptr += 4;
	*(unsigned int *)(ptr) = __size_type; ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	if (length != NULL) stream->readback(length, __size_length);
	stream->readback(size, __size_size);
	stream->readback(type, __size_type);
	if (name != NULL) stream->readback(name, __size_name);
}

void glGetActiveUniform_enc(void *self , GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_size =  (sizeof(GLint));
	const unsigned int __size_type =  (sizeof(GLenum));
	const unsigned int __size_name = ((name != NULL) ?  bufsize : 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + __size_length + __size_size + __size_type + __size_name + 4*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetActiveUniform;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_size; ptr += 4;
	*(unsigned int *)(ptr) = __size_type; ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	if (length != NULL) stream->readback(length, __size_length);
	stream->readback(size, __size_size);
	stream->readback(type, __size_type);
	if (name != NULL) stream->readback(name, __size_name);
}

void glGetAttachedShaders_enc(void *self , GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_count = ((count != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_shaders =  (maxcount*sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_count + __size_shaders + 2*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetAttachedShaders;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &maxcount, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_count; ptr += 4;
	*(unsigned int *)(ptr) = __size_shaders; ptr += 4;
	if (count != NULL) stream->readback(count, __size_count);
	stream->readback(shaders, __size_shaders);
}

int glGetAttribLocation_enc(void *self , GLuint program, const GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_name =  (strlen(name) + 1);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_name + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetAttribLocation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	memcpy(ptr, name, __size_name);ptr += __size_name;

	int retval;
	stream->readback(&retval, 4);
	return retval;
}

void glGetBooleanv_enc(void *self , GLenum pname, GLboolean* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLboolean));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetBooleanv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetBufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetBufferParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

GLenum glGetError_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 0;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetError;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;


	GLenum retval;
	stream->readback(&retval, 4);
	return retval;
}

void glGetFloatv_enc(void *self , GLenum pname, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetFloatv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetFramebufferAttachmentParameteriv_enc(void *self , GLenum target, GLenum attachment, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetFramebufferAttachmentParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetIntegerv_enc(void *self , GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetIntegerv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetProgramiv_enc(void *self , GLuint program, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  sizeof(GLint);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetProgramiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetProgramInfoLog_enc(void *self , GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_length =  sizeof(GLsizei);
	const unsigned int __size_infolog =  bufsize;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_length + __size_infolog + 2*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetProgramInfoLog;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_infolog; ptr += 4;
	stream->readback(length, __size_length);
	stream->readback(infolog, __size_infolog);
}

void glGetRenderbufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  sizeof(GLint);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetRenderbufferParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetShaderiv_enc(void *self , GLuint shader, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  sizeof(GLint);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetShaderiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetShaderInfoLog_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_infolog =  bufsize;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_length + __size_infolog + 2*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetShaderInfoLog;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_infolog; ptr += 4;
	if (length != NULL) stream->readback(length, __size_length);
	stream->readback(infolog, __size_infolog);
}

void glGetShaderPrecisionFormat_enc(void *self , GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_range =  (2 * sizeof(GLint));
	const unsigned int __size_precision =  (sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_range + __size_precision + 2*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetShaderPrecisionFormat;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shadertype, 4); ptr += 4;
		memcpy(ptr, &precisiontype, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_range; ptr += 4;
	*(unsigned int *)(ptr) = __size_precision; ptr += 4;
	stream->readback(range, __size_range);
	stream->readback(precision, __size_precision);
}

void glGetShaderSource_enc(void *self , GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_length = ((length != NULL) ?  (sizeof(GLsizei)) : 0);
	const unsigned int __size_source =  bufsize;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_length + __size_source + 2*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetShaderSource;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
		memcpy(ptr, &bufsize, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_length; ptr += 4;
	*(unsigned int *)(ptr) = __size_source; ptr += 4;
	if (length != NULL) stream->readback(length, __size_length);
	stream->readback(source, __size_source);
}

void glGetTexParameterfv_enc(void *self , GLenum target, GLenum pname, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetTexParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetTexParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetTexParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetUniformfv_enc(void *self , GLuint program, GLint location, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  glSizeof(uniformType(self, program, location));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetUniformfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &location, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetUniformiv_enc(void *self , GLuint program, GLint location, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  glSizeof(uniformType(self, program, location));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetUniformiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
		memcpy(ptr, &location, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

int glGetUniformLocation_enc(void *self , GLuint program, const GLchar* name)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_name =  (strlen(name) + 1);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_name + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetUniformLocation;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_name; ptr += 4;
	memcpy(ptr, name, __size_name);ptr += __size_name;

	int retval;
	stream->readback(&retval, 4);
	return retval;
}

void glGetVertexAttribfv_enc(void *self , GLuint index, GLenum pname, GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetVertexAttribfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glGetVertexAttribiv_enc(void *self , GLuint index, GLenum pname, GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetVertexAttribiv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &index, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	stream->readback(params, __size_params);
}

void glHint_enc(void *self , GLenum target, GLenum mode)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glHint;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &mode, 4); ptr += 4;
}

GLboolean glIsBuffer_enc(void *self , GLuint buffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &buffer, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

GLboolean glIsEnabled_enc(void *self , GLenum cap)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsEnabled;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

GLboolean glIsFramebuffer_enc(void *self , GLuint framebuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsFramebuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &framebuffer, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

GLboolean glIsProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

GLboolean glIsRenderbuffer_enc(void *self , GLuint renderbuffer)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsRenderbuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &renderbuffer, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

GLboolean glIsShader_enc(void *self , GLuint shader)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsShader;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

GLboolean glIsTexture_enc(void *self , GLuint texture)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

void glLineWidth_enc(void *self , GLfloat width)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glLineWidth;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &width, 4); ptr += 4;
}

void glLinkProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glLinkProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
}

void glPixelStorei_enc(void *self , GLenum pname, GLint param)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glPixelStorei;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;
}

void glPolygonOffset_enc(void *self , GLfloat factor, GLfloat units)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glPolygonOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &factor, 4); ptr += 4;
		memcpy(ptr, &units, 4); ptr += 4;
}

void glReadPixels_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_pixels =  pixelDataSize(self, width, height, format, type, 1);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glReadPixels;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_pixels; ptr += 4;
	stream->readback(pixels, __size_pixels);
}

void glReleaseShaderCompiler_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 0;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glReleaseShaderCompiler;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

}

void glRenderbufferStorage_enc(void *self , GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glRenderbufferStorage;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
}

void glSampleCoverage_enc(void *self , GLclampf value, GLboolean invert)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 1;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glSampleCoverage;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &value, 4); ptr += 4;
		memcpy(ptr, &invert, 1); ptr += 1;
}

void glScissor_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glScissor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
}

void glStencilFunc_enc(void *self , GLenum func, GLint ref, GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glStencilFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;
		memcpy(ptr, &mask, 4); ptr += 4;
}

void glStencilFuncSeparate_enc(void *self , GLenum face, GLenum func, GLint ref, GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glStencilFuncSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;
		memcpy(ptr, &mask, 4); ptr += 4;
}

void glStencilMask_enc(void *self , GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glStencilMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mask, 4); ptr += 4;
}

void glStencilMaskSeparate_enc(void *self , GLenum face, GLuint mask)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glStencilMaskSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &mask, 4); ptr += 4;
}

void glStencilOp_enc(void *self , GLenum fail, GLenum zfail, GLenum zpass)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glStencilOp;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &fail, 4); ptr += 4;
		memcpy(ptr, &zfail, 4); ptr += 4;
		memcpy(ptr, &zpass, 4); ptr += 4;
}

void glStencilOpSeparate_enc(void *self , GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glStencilOpSeparate;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &fail, 4); ptr += 4;
		memcpy(ptr, &zfail, 4); ptr += 4;
		memcpy(ptr, &zpass, 4); ptr += 4;
}

void glTexImage2D_enc(void *self , GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_pixels = ((pixels != NULL) ?  pixelDataSize(self, width, height, format, type, 0) : 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (pixels != NULL) stream->writeFully(pixels, __size_pixels);
}

void glTexParameterf_enc(void *self , GLenum target, GLenum pname, GLfloat param)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glTexParameterf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;
}

void glTexParameterfv_enc(void *self , GLenum target, GLenum pname, const GLfloat* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glTexParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;
}

void glTexParameteri_enc(void *self , GLenum target, GLenum pname, GLint param)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glTexParameteri;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;
}

void glTexParameteriv_enc(void *self , GLenum target, GLenum pname, const GLint* params)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_params + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glTexParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_params; ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;
}

void glTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_pixels =  pixelDataSize(self, width, height, format, type, 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	stream->writeFully(pixels, __size_pixels);
}

void glUniform1f_enc(void *self , GLint location, GLfloat x)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform1f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
}

void glUniform1fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (count * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform1fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniform1i_enc(void *self , GLint location, GLint x)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform1i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
}

void glUniform1iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (count * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform1iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniform2f_enc(void *self , GLint location, GLfloat x, GLfloat y)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform2f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
}

void glUniform2fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (count * 2 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform2fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniform2i_enc(void *self , GLint location, GLint x, GLint y)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform2i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
}

void glUniform2iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (count * 2 * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform2iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniform3f_enc(void *self , GLint location, GLfloat x, GLfloat y, GLfloat z)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform3f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
}

void glUniform3fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (count * 3 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform3fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniform3i_enc(void *self , GLint location, GLint x, GLint y, GLint z)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform3i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
}

void glUniform3iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (3 * count * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform3iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniform4f_enc(void *self , GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform4f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &w, 4); ptr += 4;
}

void glUniform4fv_enc(void *self , GLint location, GLsizei count, const GLfloat* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (4 * count * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform4fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniform4i_enc(void *self , GLint location, GLint x, GLint y, GLint z, GLint w)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform4i;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &w, 4); ptr += 4;
}

void glUniform4iv_enc(void *self , GLint location, GLsizei count, const GLint* v)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_v =  (4 * count * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_v + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniform4iv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_v; ptr += 4;
	memcpy(ptr, v, __size_v);ptr += __size_v;
}

void glUniformMatrix2fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_value =  (count * 4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 1 + __size_value + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniformMatrix2fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &transpose, 1); ptr += 1;
	*(unsigned int *)(ptr) = __size_value; ptr += 4;
	memcpy(ptr, value, __size_value);ptr += __size_value;
}

void glUniformMatrix3fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_value =  (count * 9 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 1 + __size_value + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniformMatrix3fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &transpose, 1); ptr += 1;
	*(unsigned int *)(ptr) = __size_value; ptr += 4;
	memcpy(ptr, value, __size_value);ptr += __size_value;
}

void glUniformMatrix4fv_enc(void *self , GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_value =  (count * 16 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 1 + __size_value + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUniformMatrix4fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &location, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &transpose, 1); ptr += 1;
	*(unsigned int *)(ptr) = __size_value; ptr += 4;
	memcpy(ptr, value, __size_value);ptr += __size_value;
}

void glUseProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUseProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
}

void glValidateProgram_enc(void *self , GLuint program)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glValidateProgram;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;
}

void glVertexAttrib1f_enc(void *self , GLuint indx, GLfloat x)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib1f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
}

void glVertexAttrib1fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_values =  (sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_values + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib1fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;
}

void glVertexAttrib2f_enc(void *self , GLuint indx, GLfloat x, GLfloat y)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib2f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
}

void glVertexAttrib2fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_values =  (2 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_values + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib2fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;
}

void glVertexAttrib3f_enc(void *self , GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib3f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
}

void glVertexAttrib3fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_values =  (3 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_values + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib3fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;
}

void glVertexAttrib4f_enc(void *self , GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib4f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &w, 4); ptr += 4;
}

void glVertexAttrib4fv_enc(void *self , GLuint indx, const GLfloat* values)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_values =  (4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_values + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttrib4fv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_values; ptr += 4;
	memcpy(ptr, values, __size_values);ptr += __size_values;
}

void glViewport_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glViewport;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
}

void glEGLImageTargetTexture2DOES_enc(void *self , GLenum target, GLeglImageOES image)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glEGLImageTargetTexture2DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &image, 4); ptr += 4;
}

void glEGLImageTargetRenderbufferStorageOES_enc(void *self , GLenum target, GLeglImageOES image)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glEGLImageTargetRenderbufferStorageOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &image, 4); ptr += 4;
}

GLboolean glUnmapBufferOES_enc(void *self , GLenum target)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glUnmapBufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

void glTexImage3DOES_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_pixels = ((pixels != NULL) ?  pixelDataSize3D(self, width, height, depth, format, type, 0) : 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glTexImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (pixels != NULL) stream->writeFully(pixels, __size_pixels);
}

void glTexSubImage3DOES_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_pixels =  pixelDataSize3D(self, width, height, depth, format, type, 0);
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glTexSubImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	stream->writeFully(pixels, __size_pixels);
}

void glCopyTexSubImage3DOES_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glCopyTexSubImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
}

void glCompressedTexImage3DOES_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data =  imageSize;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glCompressedTexImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_data,4);
	stream->writeFully(data, __size_data);
}

void glCompressedTexSubImage3DOES_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data =  imageSize;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	ptr = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	int tmp = OP_glCompressedTexSubImage3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;
	stream->flush();
	stream->writeFully(&__size_data,4);
	stream->writeFully(data, __size_data);
}

void glFramebufferTexture3DOES_enc(void *self , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glFramebufferTexture3DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &textarget, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
}

void glBindVertexArrayOES_enc(void *self , GLuint array)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glBindVertexArrayOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;
}

void glDeleteVertexArraysOES_enc(void *self , GLsizei n, const GLuint* arrays)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_arrays =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_arrays + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDeleteVertexArraysOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_arrays; ptr += 4;
	memcpy(ptr, arrays, __size_arrays);ptr += __size_arrays;
}

void glGenVertexArraysOES_enc(void *self , GLsizei n, GLuint* arrays)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_arrays =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_arrays + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGenVertexArraysOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_arrays; ptr += 4;
	stream->readback(arrays, __size_arrays);
}

GLboolean glIsVertexArrayOES_enc(void *self , GLuint array)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glIsVertexArrayOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;

	GLboolean retval;
	stream->readback(&retval, 1);
	return retval;
}

void glDiscardFramebufferEXT_enc(void *self , GLenum target, GLsizei numAttachments, const GLenum* attachments)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_attachments =  (numAttachments * sizeof(GLenum));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + __size_attachments + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDiscardFramebufferEXT;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &numAttachments, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_attachments; ptr += 4;
	memcpy(ptr, attachments, __size_attachments);ptr += __size_attachments;
}

void glVertexAttribPointerData_enc(void *self , GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* data, GLuint datalen)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 1 + 4 + __size_data + 4 + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttribPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &normalized, 1); ptr += 1;
		memcpy(ptr, &stride, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_data; ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, size, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;
}

void glVertexAttribPointerOffset_enc(void *self , GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint offset)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 1 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glVertexAttribPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &indx, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &normalized, 1); ptr += 1;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;
}

void glDrawElementsOffset_enc(void *self , GLenum mode, GLsizei count, GLenum type, GLuint offset)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + 4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDrawElementsOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;
}

void glDrawElementsData_enc(void *self , GLenum mode, GLsizei count, GLenum type, void* data, GLuint datalen)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glDrawElementsData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_data; ptr += 4;
	memcpy(ptr, data, __size_data);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;
}

void glGetCompressedTextureFormats_enc(void *self , int count, GLint* formats)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_formats =  (count * sizeof(GLint));
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_formats + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glGetCompressedTextureFormats;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &count, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_formats; ptr += 4;
	stream->readback(formats, __size_formats);
}

void glShaderString_enc(void *self , GLuint shader, const GLchar* string, GLsizei len)
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	const unsigned int __size_string =  len;
	 unsigned char *ptr;
	 const size_t packetSize = 8 + 4 + __size_string + 4 + 1*4;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glShaderString;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;

		memcpy(ptr, &shader, 4); ptr += 4;
	*(unsigned int *)(ptr) = __size_string; ptr += 4;
	memcpy(ptr, string, __size_string);ptr += __size_string;
		memcpy(ptr, &len, 4); ptr += 4;
}

int glFinishRoundTrip_enc(void *self )
{

	gl2_encoder_context_t *ctx = (gl2_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;

	 unsigned char *ptr;
	 const size_t packetSize = 8 + 0;
	ptr = stream->alloc(packetSize);
	int tmp = OP_glFinishRoundTrip;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &packetSize, 4);  ptr += 4;


	int retval;
	stream->readback(&retval, 4);
	return retval;
}

gl2_encoder_context_t::gl2_encoder_context_t(IOStream *stream)
{
	m_stream = stream;

	set_glActiveTexture(glActiveTexture_enc);
	set_glAttachShader(glAttachShader_enc);
	set_glBindAttribLocation(glBindAttribLocation_enc);
	set_glBindBuffer(glBindBuffer_enc);
	set_glBindFramebuffer(glBindFramebuffer_enc);
	set_glBindRenderbuffer(glBindRenderbuffer_enc);
	set_glBindTexture(glBindTexture_enc);
	set_glBlendColor(glBlendColor_enc);
	set_glBlendEquation(glBlendEquation_enc);
	set_glBlendEquationSeparate(glBlendEquationSeparate_enc);
	set_glBlendFunc(glBlendFunc_enc);
	set_glBlendFuncSeparate(glBlendFuncSeparate_enc);
	set_glBufferData(glBufferData_enc);
	set_glBufferSubData(glBufferSubData_enc);
	set_glCheckFramebufferStatus(glCheckFramebufferStatus_enc);
	set_glClear(glClear_enc);
	set_glClearColor(glClearColor_enc);
	set_glClearDepthf(glClearDepthf_enc);
	set_glClearStencil(glClearStencil_enc);
	set_glColorMask(glColorMask_enc);
	set_glCompileShader(glCompileShader_enc);
	set_glCompressedTexImage2D(glCompressedTexImage2D_enc);
	set_glCompressedTexSubImage2D(glCompressedTexSubImage2D_enc);
	set_glCopyTexImage2D(glCopyTexImage2D_enc);
	set_glCopyTexSubImage2D(glCopyTexSubImage2D_enc);
	set_glCreateProgram(glCreateProgram_enc);
	set_glCreateShader(glCreateShader_enc);
	set_glCullFace(glCullFace_enc);
	set_glDeleteBuffers(glDeleteBuffers_enc);
	set_glDeleteFramebuffers(glDeleteFramebuffers_enc);
	set_glDeleteProgram(glDeleteProgram_enc);
	set_glDeleteRenderbuffers(glDeleteRenderbuffers_enc);
	set_glDeleteShader(glDeleteShader_enc);
	set_glDeleteTextures(glDeleteTextures_enc);
	set_glDepthFunc(glDepthFunc_enc);
	set_glDepthMask(glDepthMask_enc);
	set_glDepthRangef(glDepthRangef_enc);
	set_glDetachShader(glDetachShader_enc);
	set_glDisable(glDisable_enc);
	set_glDisableVertexAttribArray(glDisableVertexAttribArray_enc);
	set_glDrawArrays(glDrawArrays_enc);
	set_glDrawElements((glDrawElements_client_proc_t)(enc_unsupported));
	set_glEnable(glEnable_enc);
	set_glEnableVertexAttribArray(glEnableVertexAttribArray_enc);
	set_glFinish(glFinish_enc);
	set_glFlush(glFlush_enc);
	set_glFramebufferRenderbuffer(glFramebufferRenderbuffer_enc);
	set_glFramebufferTexture2D(glFramebufferTexture2D_enc);
	set_glFrontFace(glFrontFace_enc);
	set_glGenBuffers(glGenBuffers_enc);
	set_glGenerateMipmap(glGenerateMipmap_enc);
	set_glGenFramebuffers(glGenFramebuffers_enc);
	set_glGenRenderbuffers(glGenRenderbuffers_enc);
	set_glGenTextures(glGenTextures_enc);
	set_glGetActiveAttrib(glGetActiveAttrib_enc);
	set_glGetActiveUniform(glGetActiveUniform_enc);
	set_glGetAttachedShaders(glGetAttachedShaders_enc);
	set_glGetAttribLocation(glGetAttribLocation_enc);
	set_glGetBooleanv(glGetBooleanv_enc);
	set_glGetBufferParameteriv(glGetBufferParameteriv_enc);
	set_glGetError(glGetError_enc);
	set_glGetFloatv(glGetFloatv_enc);
	set_glGetFramebufferAttachmentParameteriv(glGetFramebufferAttachmentParameteriv_enc);
	set_glGetIntegerv(glGetIntegerv_enc);
	set_glGetProgramiv(glGetProgramiv_enc);
	set_glGetProgramInfoLog(glGetProgramInfoLog_enc);
	set_glGetRenderbufferParameteriv(glGetRenderbufferParameteriv_enc);
	set_glGetShaderiv(glGetShaderiv_enc);
	set_glGetShaderInfoLog(glGetShaderInfoLog_enc);
	set_glGetShaderPrecisionFormat(glGetShaderPrecisionFormat_enc);
	set_glGetShaderSource(glGetShaderSource_enc);
	set_glGetString((glGetString_client_proc_t)(enc_unsupported));
	set_glGetTexParameterfv(glGetTexParameterfv_enc);
	set_glGetTexParameteriv(glGetTexParameteriv_enc);
	set_glGetUniformfv(glGetUniformfv_enc);
	set_glGetUniformiv(glGetUniformiv_enc);
	set_glGetUniformLocation(glGetUniformLocation_enc);
	set_glGetVertexAttribfv(glGetVertexAttribfv_enc);
	set_glGetVertexAttribiv(glGetVertexAttribiv_enc);
	set_glGetVertexAttribPointerv((glGetVertexAttribPointerv_client_proc_t)(enc_unsupported));
	set_glHint(glHint_enc);
	set_glIsBuffer(glIsBuffer_enc);
	set_glIsEnabled(glIsEnabled_enc);
	set_glIsFramebuffer(glIsFramebuffer_enc);
	set_glIsProgram(glIsProgram_enc);
	set_glIsRenderbuffer(glIsRenderbuffer_enc);
	set_glIsShader(glIsShader_enc);
	set_glIsTexture(glIsTexture_enc);
	set_glLineWidth(glLineWidth_enc);
	set_glLinkProgram(glLinkProgram_enc);
	set_glPixelStorei(glPixelStorei_enc);
	set_glPolygonOffset(glPolygonOffset_enc);
	set_glReadPixels(glReadPixels_enc);
	set_glReleaseShaderCompiler(glReleaseShaderCompiler_enc);
	set_glRenderbufferStorage(glRenderbufferStorage_enc);
	set_glSampleCoverage(glSampleCoverage_enc);
	set_glScissor(glScissor_enc);
	set_glShaderBinary((glShaderBinary_client_proc_t)(enc_unsupported));
	set_glShaderSource((glShaderSource_client_proc_t)(enc_unsupported));
	set_glStencilFunc(glStencilFunc_enc);
	set_glStencilFuncSeparate(glStencilFuncSeparate_enc);
	set_glStencilMask(glStencilMask_enc);
	set_glStencilMaskSeparate(glStencilMaskSeparate_enc);
	set_glStencilOp(glStencilOp_enc);
	set_glStencilOpSeparate(glStencilOpSeparate_enc);
	set_glTexImage2D(glTexImage2D_enc);
	set_glTexParameterf(glTexParameterf_enc);
	set_glTexParameterfv(glTexParameterfv_enc);
	set_glTexParameteri(glTexParameteri_enc);
	set_glTexParameteriv(glTexParameteriv_enc);
	set_glTexSubImage2D(glTexSubImage2D_enc);
	set_glUniform1f(glUniform1f_enc);
	set_glUniform1fv(glUniform1fv_enc);
	set_glUniform1i(glUniform1i_enc);
	set_glUniform1iv(glUniform1iv_enc);
	set_glUniform2f(glUniform2f_enc);
	set_glUniform2fv(glUniform2fv_enc);
	set_glUniform2i(glUniform2i_enc);
	set_glUniform2iv(glUniform2iv_enc);
	set_glUniform3f(glUniform3f_enc);
	set_glUniform3fv(glUniform3fv_enc);
	set_glUniform3i(glUniform3i_enc);
	set_glUniform3iv(glUniform3iv_enc);
	set_glUniform4f(glUniform4f_enc);
	set_glUniform4fv(glUniform4fv_enc);
	set_glUniform4i(glUniform4i_enc);
	set_glUniform4iv(glUniform4iv_enc);
	set_glUniformMatrix2fv(glUniformMatrix2fv_enc);
	set_glUniformMatrix3fv(glUniformMatrix3fv_enc);
	set_glUniformMatrix4fv(glUniformMatrix4fv_enc);
	set_glUseProgram(glUseProgram_enc);
	set_glValidateProgram(glValidateProgram_enc);
	set_glVertexAttrib1f(glVertexAttrib1f_enc);
	set_glVertexAttrib1fv(glVertexAttrib1fv_enc);
	set_glVertexAttrib2f(glVertexAttrib2f_enc);
	set_glVertexAttrib2fv(glVertexAttrib2fv_enc);
	set_glVertexAttrib3f(glVertexAttrib3f_enc);
	set_glVertexAttrib3fv(glVertexAttrib3fv_enc);
	set_glVertexAttrib4f(glVertexAttrib4f_enc);
	set_glVertexAttrib4fv(glVertexAttrib4fv_enc);
	set_glVertexAttribPointer((glVertexAttribPointer_client_proc_t)(enc_unsupported));
	set_glViewport(glViewport_enc);
	set_glEGLImageTargetTexture2DOES(glEGLImageTargetTexture2DOES_enc);
	set_glEGLImageTargetRenderbufferStorageOES(glEGLImageTargetRenderbufferStorageOES_enc);
	set_glGetProgramBinaryOES((glGetProgramBinaryOES_client_proc_t)(enc_unsupported));
	set_glProgramBinaryOES((glProgramBinaryOES_client_proc_t)(enc_unsupported));
	set_glMapBufferOES((glMapBufferOES_client_proc_t)(enc_unsupported));
	set_glUnmapBufferOES(glUnmapBufferOES_enc);
	set_glTexImage3DOES(glTexImage3DOES_enc);
	set_glTexSubImage3DOES(glTexSubImage3DOES_enc);
	set_glCopyTexSubImage3DOES(glCopyTexSubImage3DOES_enc);
	set_glCompressedTexImage3DOES(glCompressedTexImage3DOES_enc);
	set_glCompressedTexSubImage3DOES(glCompressedTexSubImage3DOES_enc);
	set_glFramebufferTexture3DOES(glFramebufferTexture3DOES_enc);
	set_glBindVertexArrayOES(glBindVertexArrayOES_enc);
	set_glDeleteVertexArraysOES(glDeleteVertexArraysOES_enc);
	set_glGenVertexArraysOES(glGenVertexArraysOES_enc);
	set_glIsVertexArrayOES(glIsVertexArrayOES_enc);
	set_glDiscardFramebufferEXT(glDiscardFramebufferEXT_enc);
	set_glMultiDrawArraysEXT((glMultiDrawArraysEXT_client_proc_t)(enc_unsupported));
	set_glMultiDrawElementsEXT((glMultiDrawElementsEXT_client_proc_t)(enc_unsupported));
	set_glGetPerfMonitorGroupsAMD((glGetPerfMonitorGroupsAMD_client_proc_t)(enc_unsupported));
	set_glGetPerfMonitorCountersAMD((glGetPerfMonitorCountersAMD_client_proc_t)(enc_unsupported));
	set_glGetPerfMonitorGroupStringAMD((glGetPerfMonitorGroupStringAMD_client_proc_t)(enc_unsupported));
	set_glGetPerfMonitorCounterStringAMD((glGetPerfMonitorCounterStringAMD_client_proc_t)(enc_unsupported));
	set_glGetPerfMonitorCounterInfoAMD((glGetPerfMonitorCounterInfoAMD_client_proc_t)(enc_unsupported));
	set_glGenPerfMonitorsAMD((glGenPerfMonitorsAMD_client_proc_t)(enc_unsupported));
	set_glDeletePerfMonitorsAMD((glDeletePerfMonitorsAMD_client_proc_t)(enc_unsupported));
	set_glSelectPerfMonitorCountersAMD((glSelectPerfMonitorCountersAMD_client_proc_t)(enc_unsupported));
	set_glBeginPerfMonitorAMD((glBeginPerfMonitorAMD_client_proc_t)(enc_unsupported));
	set_glEndPerfMonitorAMD((glEndPerfMonitorAMD_client_proc_t)(enc_unsupported));
	set_glGetPerfMonitorCounterDataAMD((glGetPerfMonitorCounterDataAMD_client_proc_t)(enc_unsupported));
	set_glRenderbufferStorageMultisampleIMG((glRenderbufferStorageMultisampleIMG_client_proc_t)(enc_unsupported));
	set_glFramebufferTexture2DMultisampleIMG((glFramebufferTexture2DMultisampleIMG_client_proc_t)(enc_unsupported));
	set_glDeleteFencesNV((glDeleteFencesNV_client_proc_t)(enc_unsupported));
	set_glGenFencesNV((glGenFencesNV_client_proc_t)(enc_unsupported));
	set_glIsFenceNV((glIsFenceNV_client_proc_t)(enc_unsupported));
	set_glTestFenceNV((glTestFenceNV_client_proc_t)(enc_unsupported));
	set_glGetFenceivNV((glGetFenceivNV_client_proc_t)(enc_unsupported));
	set_glFinishFenceNV((glFinishFenceNV_client_proc_t)(enc_unsupported));
	set_glSetFenceNV((glSetFenceNV_client_proc_t)(enc_unsupported));
	set_glCoverageMaskNV((glCoverageMaskNV_client_proc_t)(enc_unsupported));
	set_glCoverageOperationNV((glCoverageOperationNV_client_proc_t)(enc_unsupported));
	set_glGetDriverControlsQCOM((glGetDriverControlsQCOM_client_proc_t)(enc_unsupported));
	set_glGetDriverControlStringQCOM((glGetDriverControlStringQCOM_client_proc_t)(enc_unsupported));
	set_glEnableDriverControlQCOM((glEnableDriverControlQCOM_client_proc_t)(enc_unsupported));
	set_glDisableDriverControlQCOM((glDisableDriverControlQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetTexturesQCOM((glExtGetTexturesQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetBuffersQCOM((glExtGetBuffersQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetRenderbuffersQCOM((glExtGetRenderbuffersQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetFramebuffersQCOM((glExtGetFramebuffersQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetTexLevelParameterivQCOM((glExtGetTexLevelParameterivQCOM_client_proc_t)(enc_unsupported));
	set_glExtTexObjectStateOverrideiQCOM((glExtTexObjectStateOverrideiQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetTexSubImageQCOM((glExtGetTexSubImageQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetBufferPointervQCOM((glExtGetBufferPointervQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetShadersQCOM((glExtGetShadersQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetProgramsQCOM((glExtGetProgramsQCOM_client_proc_t)(enc_unsupported));
	set_glExtIsProgramBinaryQCOM((glExtIsProgramBinaryQCOM_client_proc_t)(enc_unsupported));
	set_glExtGetProgramBinarySourceQCOM((glExtGetProgramBinarySourceQCOM_client_proc_t)(enc_unsupported));
	set_glStartTilingQCOM((glStartTilingQCOM_client_proc_t)(enc_unsupported));
	set_glEndTilingQCOM((glEndTilingQCOM_client_proc_t)(enc_unsupported));
	set_glVertexAttribPointerData(glVertexAttribPointerData_enc);
	set_glVertexAttribPointerOffset(glVertexAttribPointerOffset_enc);
	set_glDrawElementsOffset(glDrawElementsOffset_enc);
	set_glDrawElementsData(glDrawElementsData_enc);
	set_glGetCompressedTextureFormats(glGetCompressedTextureFormats_enc);
	set_glShaderString(glShaderString_enc);
	set_glFinishRoundTrip(glFinishRoundTrip_enc);
}

